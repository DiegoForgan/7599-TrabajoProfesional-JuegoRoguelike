using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Random = UnityEngine.Random;

public class RoomFirstDungeonGenerator : SimpleRandomWalkDungeonGenerator
{
    // Minimum size of the rooms that are going to be generated by splitting the total dungeon space
    [SerializeField] private int minRoomWidth = 4;
    [SerializeField] private int minRoomHeigth = 4;
    // Total size of the dungeon to be filled with rooms and corridors
    [SerializeField] private int dungeonWidth = 20;
    [SerializeField] private int dungeonHeigth = 20;
    // Offset required to not build rooms too close to each other making just one big segment
    [SerializeField] [Range(0,10)] private int offset = 1;
    // This is used to select beetween random walk generated rooms or regular square ones
    [SerializeField] private bool randomWalkRooms = false;

    protected override void RunProceduralGeneration()
    {
        CreateRooms();    
    }

    private void CreateRooms()
    {
        //1. Generate rooms space by partitioning the total dungeon size
        List<BoundsInt> roomsList = BinarySpacePartitioning(new BoundsInt((Vector3Int) startPosition,
         new Vector3Int(dungeonWidth,dungeonHeigth,0)), minRoomWidth, minRoomHeigth);
        //2. Creation of rooms
        HashSet<Vector2Int> floor = new HashSet<Vector2Int>();
        // Room Creation based on a random walk
        if(randomWalkRooms) floor = CreateRandomWalkRooms(roomsList);
        // Room creation using square and rectangular shapes
        else floor = CreateSimpleRooms(roomsList);
        //3. Gather the center of every room created to generate the corridors beetween them
        List<Vector2Int> roomCenters = new List<Vector2Int>();
        ObtainRoomCenters(roomCenters, roomsList);
        //4. Connect the rooms with corridors
        HashSet<Vector2Int> corridors = ConnectRooms(roomCenters);
        floor.UnionWith(corridors);
        //5. Show results on screen to the player
        tilemapVisualizer.PaintFloortiles(floor);
        HashSet<Vector2Int> wallsPositions = WallGenerator.GenerateWalls(floor);
        tilemapVisualizer.PaintWallstiles(wallsPositions);
    }

    private HashSet<Vector2Int> CreateRandomWalkRooms(List<BoundsInt> roomsList)
    {
        HashSet<Vector2Int> floor = new HashSet<Vector2Int>();
        for (int i = 0; i < roomsList.Count; i++)
        {
            BoundsInt roomBounds = roomsList[i];
            Vector2Int roomCenter = new Vector2Int(Mathf.RoundToInt(roomBounds.center.x),
                Mathf.RoundToInt(roomBounds.center.y));
            HashSet<Vector2Int> roomFloor = RunRandomWalk(roomCenter);
            foreach (Vector2Int position in roomFloor)
            {
                if (position.x >= (roomBounds.xMin + offset) && position.x <= (roomBounds.xMax - offset)
                    && position.y >= (roomBounds.yMin - offset) && position.y <= (roomBounds.yMax - offset))
                {
                    floor.Add(position);
                }
            }

        }
        return floor;
    }

    private HashSet<Vector2Int> ConnectRooms(List<Vector2Int> roomCenters)
    {
        HashSet<Vector2Int> corridors = new HashSet<Vector2Int>();
        // Select a random room to start the process
        Vector2Int currentRoomCenter = roomCenters[Random.Range(0,roomCenters.Count)];
        roomCenters.Remove(currentRoomCenter);

        while (roomCenters.Count > 0)
        {
            //Get the closest room to the one being considered on this iteration to make the shortest corridor
            Vector2Int closest = FindClosestRoomCenter(currentRoomCenter ,roomCenters);
            roomCenters.Remove(closest);
            // Create the positions of the new corridor thats going to connect both rooms in consideration
            HashSet<Vector2Int> newCorridor = CreateCorridorBeetweenRooms(currentRoomCenter, closest);
            currentRoomCenter = closest;
            corridors.UnionWith(newCorridor);
        }
        // Return all the positions where corridors should be placed
        return corridors;
    }

    private HashSet<Vector2Int> CreateCorridorBeetweenRooms(Vector2Int origin, Vector2Int destination)
    {
        HashSet<Vector2Int> corridor = new HashSet<Vector2Int>();
        Vector2Int currentPosition = origin;
        corridor.Add(currentPosition);
        // To reach the destination, first align Y axis
        while (destination.y != currentPosition.y)
        {
             if (destination.y > currentPosition.y) currentPosition += Vector2Int.up;
             else currentPosition += Vector2Int.down;

             corridor.Add(currentPosition);
        }
        // Then we align the X axis
        while (destination.x != currentPosition.x)
        {
            if (destination.x > currentPosition.x) currentPosition += Vector2Int.right;
            else currentPosition += Vector2Int.left;

            corridor.Add(currentPosition); 
        }
        
        return corridor;
    }

    private Vector2Int FindClosestRoomCenter(Vector2Int currentRoomCenter, List<Vector2Int> roomCenters)
    {
        Vector2Int closest = Vector2Int.zero;
        float currentMinDistance = float.MaxValue;

        foreach (Vector2Int center in roomCenters)
        {
            float distance = Vector2.Distance(center, currentRoomCenter);
            if( distance < currentMinDistance){
                closest = center;
                currentMinDistance = distance;
            }
        }
        return closest;
    }

    private void ObtainRoomCenters(List<Vector2Int> roomCenters, List<BoundsInt> roomsList)
    {
        foreach (BoundsInt room in roomsList)
        {
            roomCenters.Add((Vector2Int) Vector3Int.RoundToInt(room.center));    
        }
    }

    private List<BoundsInt> BinarySpacePartitioning(BoundsInt spaceToSplit, int minWidth, int minHeigth)
    {
        Queue<BoundsInt> roomsQueue = new Queue<BoundsInt>();
        List<BoundsInt> roomsList = new List<BoundsInt>();
        roomsQueue.Enqueue(spaceToSplit);

        while (roomsQueue.Count > 0)
        {
            BoundsInt room = roomsQueue.Dequeue();
            // Checks if the current splitted space has enough space to contain a room
            if ( room.size.x >= minWidth && room.size.y >= minHeigth){
                // This is just a simple way to choose randomly beetween a Vertical split or a Horizontal split
                if (Random.value < 0.5f){
                    //Prefer splitting Horizontally
                    if(room.size.y >= (minHeigth * 2)) SplitHorizontally(minHeigth,roomsQueue,room);
                    else if (room.size.x >= (minRoomWidth * 2)) SplitVertically(minWidth,roomsQueue,room);
                    else roomsList.Add(room);

                }
                else{
                    //Prefer splitting Vertically
                    if (room.size.x >= (minRoomWidth * 2)) SplitVertically(minWidth,roomsQueue,room);
                    else if(room.size.y >= (minHeigth * 2)) SplitHorizontally(minHeigth,roomsQueue,room);
                    else roomsList.Add(room);
                }    
            }     
        }

        return roomsList;
    }

    private void SplitVertically(int minWidth, Queue<BoundsInt> roomsQueue, BoundsInt room)
    {
        int xSplit = Random.Range(1,room.size.x);
        BoundsInt room1 = new BoundsInt(room.min,new Vector3Int(xSplit,room.size.y,room.size.z));
        BoundsInt room2 = new BoundsInt(new Vector3Int(room.min.x + xSplit,room.min.y,room.min.z),
            new Vector3Int(room.size.x - xSplit,room.size.y,room.size.z));
        roomsQueue.Enqueue(room1);
        roomsQueue.Enqueue(room2);
    }

    private void SplitHorizontally(int minHeigth, Queue<BoundsInt> roomsQueue, BoundsInt room)
    {
        int ySplit = Random.Range(1,room.size.y);
        BoundsInt room1 = new BoundsInt(room.min, new Vector3Int(room.size.x, ySplit, room.size.z));
        BoundsInt room2 = new BoundsInt(new Vector3Int(room.min.x,room.min.y + ySplit, room.min.z),
            new Vector3Int(room.size.x, room.size.y - ySplit, room.size.z));
        roomsQueue.Enqueue(room1);
        roomsQueue.Enqueue(room2);
    }

    private HashSet<Vector2Int> CreateSimpleRooms(List<BoundsInt> roomsList)
    {
        HashSet<Vector2Int> floor = new HashSet<Vector2Int>();
        foreach (BoundsInt room in roomsList)
        {
            for (int col = offset; col < (room.size.x - offset); col++)
            {
                for (int row = offset; row < (room.size.y - offset); row++)
                {
                    Vector2Int position = (Vector2Int) room.min + new Vector2Int(col,row);
                    floor.Add(position);     
                }    
            }
        }
        return floor;
    }
}
